//! TypeScript client code generator.
//!
//! Generates TypeScript interfaces, async functions, and type-safe API methods.

use crate::compiler::models::*;

/// Generate a complete TypeScript client module from a compiled schema.
pub fn generate_typescript(schema: &CompiledSchema) -> String {
    let mut out = String::new();
    let domain = &schema.domain;

    // Header
    out.push_str(&format!("// Auto-generated Cortex client for {domain}\n"));
    out.push_str("// Generated by Cortex Web Compiler — do not edit manually\n");
    out.push_str(&format!(
        "// Schema: {} models, {} actions, {} relationships\n\n",
        schema.models.len(),
        schema.actions.len(),
        schema.relationships.len()
    ));

    out.push_str("import { map, query, act, SiteMap, NodeResult } from '@cortex/client';\n\n");
    out.push_str(&format!("const DOMAIN = '{domain}';\n"));
    out.push_str("let _site: SiteMap | null = null;\n\n");
    out.push_str("async function ensureMapped(): Promise<SiteMap> {\n");
    out.push_str("  if (_site === null) {\n");
    out.push_str("    _site = await map(DOMAIN);\n");
    out.push_str("  }\n");
    out.push_str("  return _site;\n");
    out.push_str("}\n\n");

    // Generate interfaces
    for model in &schema.models {
        generate_ts_interface(&mut out, model);
    }

    // Generate functions for each model
    for model in &schema.models {
        generate_ts_functions(&mut out, model, schema);
    }

    // Top-level convenience
    out.push_str("// ── Convenience functions ──\n\n");
    let search_models: Vec<&DataModel> = schema
        .models
        .iter()
        .filter(|m| m.search_action.is_some())
        .collect();
    if let Some(primary) = search_models.first() {
        out.push_str(&format!(
            "export async function search(query: string, opts?: SearchOptions): Promise<{}[]> {{\n",
            primary.name
        ));
        out.push_str(&format!("  return search{}s(query, opts);\n", primary.name));
        out.push_str("}\n\n");
    }

    out
}

/// Generate a TypeScript interface for a model.
fn generate_ts_interface(out: &mut String, model: &DataModel) {
    out.push_str(&format!("export interface {} {{\n", model.name));

    for field in &model.fields {
        let ts_type = field.field_type.to_ts_type();
        let optional = if field.nullable { "?" } else { "" };
        let name = to_camel_case(&field.name);
        out.push_str(&format!("  {name}{optional}: {ts_type};\n"));
    }

    out.push_str("}\n\n");
}

/// Generate TypeScript functions for a model.
fn generate_ts_functions(out: &mut String, model: &DataModel, schema: &CompiledSchema) {
    let name = &model.name;

    if model.instance_count > 1 {
        // Search function
        out.push_str(&format!("export interface Search{name}Options {{\n"));
        for field in &model.fields {
            if field.feature_dim.is_some() {
                let ts_type = field.field_type.to_ts_type();
                let camel = to_camel_case(&field.name);
                out.push_str(&format!("  {camel}Min?: {ts_type};\n"));
                out.push_str(&format!("  {camel}Max?: {ts_type};\n"));
            }
        }
        out.push_str("  limit?: number;\n");
        out.push_str("}\n\n");

        // Search alias type
        out.push_str("export type SearchOptions = Search");
        out.push_str(name);
        out.push_str("Options;\n\n");

        out.push_str(&format!(
            "export async function search{name}s(\n  searchQuery: string,\n  opts?: Search{name}Options\n): Promise<{name}[]> {{\n"
        ));
        out.push_str("  const site = await ensureMapped();\n");
        out.push_str("  const features: Record<number, { lt?: number; gt?: number }> = {};\n");

        for field in &model.fields {
            if let Some(dim) = field.feature_dim {
                let camel = to_camel_case(&field.name);
                out.push_str(&format!(
                    "  if (opts?.{camel}Min !== undefined) features[{dim}] = {{ ...features[{dim}], gt: opts.{camel}Min }};\n"
                ));
                out.push_str(&format!(
                    "  if (opts?.{camel}Max !== undefined) features[{dim}] = {{ ...features[{dim}], lt: opts.{camel}Max }};\n"
                ));
            }
        }

        out.push_str(&format!(
            "  const results = await site.filter({{ pageType: 0x{:02X}, features, limit: opts?.limit ?? 20 }});\n",
            page_type_hex(&model.schema_org_type)
        ));
        out.push_str(&format!("  return results.map(fromNode{name});\n"));
        out.push_str("}\n\n");

        // getAll function
        out.push_str(&format!(
            "export async function getAll{name}s(limit: number = 100): Promise<{name}[]> {{\n"
        ));
        out.push_str("  const site = await ensureMapped();\n");
        out.push_str(&format!(
            "  const results = await site.filter({{ pageType: 0x{:02X}, limit }});\n",
            page_type_hex(&model.schema_org_type)
        ));
        out.push_str(&format!("  return results.map(fromNode{name});\n"));
        out.push_str("}\n\n");
    }

    // Instance action functions
    let instance_actions: Vec<&CompiledAction> = schema
        .actions
        .iter()
        .filter(|a| a.belongs_to == *name && a.is_instance_method)
        .collect();

    for action in &instance_actions {
        let fn_name = to_camel_case(&action.name);
        let params: Vec<String> =
            std::iter::once(format!("{}: {}", to_camel_case(&name.to_lowercase()), name))
                .chain(
                    action
                        .params
                        .iter()
                        .filter(|p| p.name != "node_id")
                        .map(|p| {
                            let ts_type = p.param_type.to_ts_type();
                            let optional = if !p.required { "?" } else { "" };
                            let default = if let Some(ref d) = p.default_value {
                                format!(" = {}", ts_default(d, &p.param_type))
                            } else {
                                String::new()
                            };
                            format!(
                                "{}{}: {}{}",
                                to_camel_case(&p.name),
                                optional,
                                ts_type,
                                default
                            )
                        }),
                )
                .collect();

        out.push_str(&format!(
            "export async function {fn_name}({params}): Promise<boolean> {{\n",
            params = params.join(", ")
        ));
        let arg_names: Vec<String> = action
            .params
            .iter()
            .filter(|p| p.name != "node_id")
            .map(|p| format!("{}: {}", p.name, to_camel_case(&p.name)))
            .collect();
        let kwargs = if arg_names.is_empty() {
            String::new()
        } else {
            format!(", {{ {} }}", arg_names.join(", "))
        };
        out.push_str(&format!(
            "  const result = await act(DOMAIN, {lower}.nodeId, '{action_name}'{kwargs});\n",
            lower = to_camel_case(&name.to_lowercase()),
            action_name = action.name,
        ));
        out.push_str("  return result.success;\n");
        out.push_str("}\n\n");
    }

    // Class action functions
    let class_actions: Vec<&CompiledAction> = schema
        .actions
        .iter()
        .filter(|a| a.belongs_to == *name && !a.is_instance_method)
        .collect();

    for action in &class_actions {
        let fn_name = to_camel_case(&action.name);
        let params: Vec<String> = action
            .params
            .iter()
            .map(|p| {
                let ts_type = p.param_type.to_ts_type();
                let optional = if !p.required { "?" } else { "" };
                format!("{}{}: {}", to_camel_case(&p.name), optional, ts_type)
            })
            .collect();

        out.push_str(&format!(
            "export async function {fn_name}({params}): Promise<unknown> {{\n",
            params = params.join(", ")
        ));
        let kwargs: Vec<String> = action
            .params
            .iter()
            .map(|p| format!("{}: {}", p.name, to_camel_case(&p.name)))
            .collect();
        let kwargs_str = if kwargs.is_empty() {
            String::new()
        } else {
            format!(", {{ {} }}", kwargs.join(", "))
        };
        out.push_str(&format!(
            "  const result = await act(DOMAIN, 0, '{action_name}'{kwargs_str});\n",
            action_name = action.name,
        ));
        out.push_str("  return result.data;\n");
        out.push_str("}\n\n");
    }

    // fromNode deserializer
    out.push_str(&format!(
        "function fromNode{name}(node: NodeResult): {name} {{\n"
    ));
    out.push_str("  return {\n");

    for field in &model.fields {
        let camel = to_camel_case(&field.name);
        if let Some(dim) = field.feature_dim {
            match field.field_type {
                FieldType::Integer => {
                    out.push_str(&format!(
                        "    {camel}: Math.round(node.feature({dim}) ?? 0),\n"
                    ));
                }
                FieldType::Bool => {
                    out.push_str(&format!("    {camel}: Boolean(node.feature({dim})),\n"));
                }
                _ => {
                    out.push_str(&format!("    {camel}: node.feature({dim}),\n"));
                }
            }
        } else {
            match field.name.as_str() {
                "url" => out.push_str("    url: node.url,\n"),
                "node_id" => out.push_str("    nodeId: node.index,\n"),
                "name" => out.push_str("    name: node.featureStr(0) ?? '',\n"),
                _ => {
                    out.push_str(&format!("    {camel}: undefined,\n"));
                }
            }
        }
    }

    out.push_str("  };\n");
    out.push_str("}\n\n");
}

/// Convert snake_case to camelCase.
fn to_camel_case(s: &str) -> String {
    let parts: Vec<&str> = s.split('_').collect();
    if parts.is_empty() {
        return s.to_string();
    }
    let mut result = parts[0].to_string();
    for part in &parts[1..] {
        if let Some(first) = part.chars().next() {
            result.push(first.to_uppercase().next().unwrap_or(first));
            result.push_str(&part[first.len_utf8()..]);
        }
    }
    result
}

/// Convert a default value to TypeScript literal.
fn ts_default(value: &str, field_type: &FieldType) -> String {
    match field_type {
        FieldType::Integer | FieldType::Float => value.to_string(),
        FieldType::Bool => value.to_string(),
        FieldType::String | FieldType::Url => format!("'{value}'"),
        _ => format!("'{value}'"),
    }
}

/// Map Schema.org type to page type hex value.
fn page_type_hex(schema_type: &str) -> u8 {
    match schema_type {
        "Product" => 0x04,
        "ProductListing" => 0x03,
        "Article" | "TechArticle" => 0x05,
        "Review" => 0x10,
        "Cart" => 0x0A,
        "WebSite" => 0x01,
        _ => 0x00,
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use chrono::Utc;

    fn minimal_schema() -> CompiledSchema {
        CompiledSchema {
            domain: "test.com".to_string(),
            compiled_at: Utc::now(),
            models: vec![DataModel {
                name: "Product".to_string(),
                schema_org_type: "Product".to_string(),
                fields: vec![
                    ModelField {
                        name: "url".to_string(),
                        field_type: FieldType::Url,
                        source: FieldSource::Inferred,
                        confidence: 1.0,
                        nullable: false,
                        example_values: vec![],
                        feature_dim: None,
                    },
                    ModelField {
                        name: "node_id".to_string(),
                        field_type: FieldType::Integer,
                        source: FieldSource::Inferred,
                        confidence: 1.0,
                        nullable: false,
                        example_values: vec![],
                        feature_dim: None,
                    },
                    ModelField {
                        name: "price".to_string(),
                        field_type: FieldType::Float,
                        source: FieldSource::JsonLd,
                        confidence: 0.99,
                        nullable: true,
                        example_values: vec![],
                        feature_dim: Some(48),
                    },
                ],
                instance_count: 50,
                example_urls: vec![],
                search_action: None,
                list_url: None,
            }],
            actions: vec![],
            relationships: vec![],
            stats: SchemaStats {
                total_models: 1,
                total_fields: 3,
                total_instances: 50,
                avg_confidence: 0.99,
            },
        }
    }

    #[test]
    fn test_generate_typescript_has_interface() {
        let code = generate_typescript(&minimal_schema());
        assert!(code.contains("export interface Product {"));
        assert!(code.contains("url: string;"));
        assert!(code.contains("price?: number;"));
    }

    #[test]
    fn test_generate_typescript_has_functions() {
        let code = generate_typescript(&minimal_schema());
        assert!(code.contains("async function searchProducts("));
        assert!(code.contains("function fromNodeProduct("));
    }

    #[test]
    fn test_to_camel_case() {
        assert_eq!(to_camel_case("node_id"), "nodeId");
        assert_eq!(to_camel_case("price"), "price");
        assert_eq!(to_camel_case("review_count"), "reviewCount");
        assert_eq!(to_camel_case("add_to_cart"), "addToCart");
    }
}
