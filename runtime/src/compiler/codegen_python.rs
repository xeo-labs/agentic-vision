//! Python client code generator.
//!
//! Generates a complete Python module with `@dataclass` models, typed methods,
//! relationship traversal, and a `_from_node()` deserializer for each model.

use crate::compiler::models::*;

/// Generate a complete Python client module from a compiled schema.
pub fn generate_python(schema: &CompiledSchema) -> String {
    let mut out = String::new();
    let domain = &schema.domain;
    let _domain_safe = domain.replace(['.', '-'], "_");

    // Header
    out.push_str(&format!(
        r#""""Auto-generated Cortex client for {domain}"""
# Generated by Cortex Web Compiler — do not edit manually
# Schema: {} models, {} actions, {} relationships

from __future__ import annotations
from dataclasses import dataclass, field
from typing import Optional, List, Any, Dict
from datetime import datetime
from cortex_client import map as _map, query as _query, act as _act

_DOMAIN = "{domain}"
_site = None


def _ensure_mapped():
    global _site
    if _site is None:
        _site = _map(_DOMAIN)
    return _site

"#,
        schema.models.len(),
        schema.actions.len(),
        schema.relationships.len()
    ));

    // Generate dataclass for each model
    for model in &schema.models {
        out.push_str(&generate_python_model(model, schema));
        out.push('\n');
    }

    // Generate top-level convenience functions
    out.push_str("\n# ── Top-level convenience functions ──\n\n");

    // Search function
    let search_models: Vec<&DataModel> = schema
        .models
        .iter()
        .filter(|m| m.search_action.is_some())
        .collect();
    if !search_models.is_empty() {
        let primary = &search_models[0];
        out.push_str(&format!(
            r#"def search(query: str, **kwargs) -> List[{name}]:
    """Search {domain}"""
    return {name}.search(query, **kwargs)

"#,
            name = primary.name
        ));
    }

    // Login function if site has auth actions
    let has_login = schema.actions.iter().any(|a| a.name == "login");
    if has_login {
        out.push_str(&format!(
            r#"def login(email: str, password: str) -> bool:
    """Log in to {domain}"""
    from cortex_client import login as _login
    return _login(_DOMAIN, method="password", credentials={{"email": email, "password": password}}).success

"#
        ));
    }

    out
}

/// Generate a Python dataclass for a single model.
fn generate_python_model(model: &DataModel, schema: &CompiledSchema) -> String {
    let mut out = String::new();

    out.push_str(&format!("\n@dataclass\nclass {}:\n", model.name));
    out.push_str(&format!(
        "    \"\"\"{}  ({} instances)\"\"\"\n",
        model.schema_org_type, model.instance_count
    ));

    // Fields — required first, then optional
    let mut required: Vec<&ModelField> = model.fields.iter().filter(|f| !f.nullable).collect();
    let mut optional: Vec<&ModelField> = model.fields.iter().filter(|f| f.nullable).collect();
    required.sort_by_key(|f| &f.name);
    optional.sort_by_key(|f| &f.name);

    for field in &required {
        let py_type = field.field_type.to_python_type();
        out.push_str(&format!(
            "    {}: {}\n",
            safe_python_name(&field.name),
            py_type
        ));
    }
    for field in &optional {
        let py_type = field.field_type.to_python_type();
        out.push_str(&format!(
            "    {}: Optional[{}] = None\n",
            safe_python_name(&field.name),
            py_type
        ));
    }
    out.push('\n');

    // Static methods: search, all
    if model.instance_count > 1 {
        // search method
        let pt_hex = format!("0x{:02X}", page_type_for_model(&model.schema_org_type));
        let name = &model.name;
        out.push_str(&format!(
            r#"    @staticmethod
    def search(query: str, limit: int = 20, **filters) -> List[{name}]:
        """Search {name}s on {{}}."""
        site = _ensure_mapped()
        feature_filters = {{}}
        for key, val in filters.items():
            dim = {name}._field_to_dim(key)
            if dim is not None:
                if isinstance(val, (int, float)):
                    feature_filters[dim] = {{"lt": val}}
                elif isinstance(val, dict):
                    feature_filters[dim] = val
        results = site.filter(page_type={pt_hex}, features=feature_filters, limit=limit)
        return [{name}._from_node(r) for r in results]

"#,
        ));

        // all method
        out.push_str(&format!(
            r#"    @staticmethod
    def all(limit: int = 100) -> List[{name}]:
        """Get all {name}s."""
        site = _ensure_mapped()
        results = site.filter(page_type={pt_hex}, limit=limit)
        return [{name}._from_node(r) for r in results]

"#,
        ));
    }

    // Instance methods from compiled actions
    let instance_actions: Vec<&CompiledAction> = schema
        .actions
        .iter()
        .filter(|a| a.belongs_to == model.name && a.is_instance_method)
        .collect();

    for action in &instance_actions {
        let params = action
            .params
            .iter()
            .filter(|p| p.name != "node_id")
            .map(|p| {
                if let Some(ref default) = p.default_value {
                    format!(
                        "{}: {} = {}",
                        safe_python_name(&p.name),
                        p.param_type.to_python_type(),
                        python_default(default, &p.param_type)
                    )
                } else if p.required {
                    format!(
                        "{}: {}",
                        safe_python_name(&p.name),
                        p.param_type.to_python_type()
                    )
                } else {
                    format!(
                        "{}: Optional[{}] = None",
                        safe_python_name(&p.name),
                        p.param_type.to_python_type()
                    )
                }
            })
            .collect::<Vec<_>>()
            .join(", ");

        let param_names: Vec<String> = action
            .params
            .iter()
            .filter(|p| p.name != "node_id")
            .map(|p| format!("{}={}", p.name, safe_python_name(&p.name)))
            .collect();
        let kwargs = if param_names.is_empty() {
            String::new()
        } else {
            format!(", {}", param_names.join(", "))
        };

        let params_sig = if params.is_empty() {
            String::new()
        } else {
            format!(", {params}")
        };

        out.push_str(&format!(
            r#"    def {name}(self{params_sig}) -> bool:
        """Execute {name} action."""
        result = _act(_DOMAIN, self.node_id, "{name}"{kwargs})
        return result.success

"#,
            name = action.name,
        ));
    }

    // Class methods from compiled actions
    let class_actions: Vec<&CompiledAction> = schema
        .actions
        .iter()
        .filter(|a| a.belongs_to == model.name && !a.is_instance_method)
        .collect();

    for action in &class_actions {
        let params = action
            .params
            .iter()
            .map(|p| {
                if let Some(ref default) = p.default_value {
                    format!(
                        "{}: {} = {}",
                        safe_python_name(&p.name),
                        p.param_type.to_python_type(),
                        python_default(default, &p.param_type)
                    )
                } else if p.required {
                    format!(
                        "{}: {}",
                        safe_python_name(&p.name),
                        p.param_type.to_python_type()
                    )
                } else {
                    format!(
                        "{}: Optional[{}] = None",
                        safe_python_name(&p.name),
                        p.param_type.to_python_type()
                    )
                }
            })
            .collect::<Vec<_>>()
            .join(", ");

        let kwargs: Vec<String> = action
            .params
            .iter()
            .map(|p| format!("{}={}", p.name, safe_python_name(&p.name)))
            .collect();
        let kwargs_str = if kwargs.is_empty() {
            String::new()
        } else {
            format!(", {}", kwargs.join(", "))
        };

        let params_sig = if params.is_empty() {
            String::new()
        } else {
            params
        };

        out.push_str(&format!(
            r#"    @staticmethod
    def {name}({params_sig}) -> Any:
        """Execute {name} action."""
        return _act(_DOMAIN, 0, "{name}"{kwargs_str}).data

"#,
            name = action.name,
        ));
    }

    // Relationship traversal methods
    let rels: Vec<&ModelRelationship> = schema
        .relationships
        .iter()
        .filter(|r| r.from_model == model.name)
        .collect();

    for rel in &rels {
        let return_type = if rel.cardinality == Cardinality::BelongsTo
            || rel.cardinality == Cardinality::HasOne
        {
            format!("Optional['{to}']", to = rel.to_model)
        } else {
            format!("List['{to}']", to = rel.to_model)
        };

        let method_name = &rel.name;

        if rel.cardinality == Cardinality::BelongsTo || rel.cardinality == Cardinality::HasOne {
            out.push_str(&format!(
                r#"    def {method_name}(self) -> {return_type}:
        """Navigate to related {to_model}."""
        site = _ensure_mapped()
        neighbors = site.neighbors(self.node_id, edge_type="{edge_type}", limit=1)
        if neighbors:
            return {to_model}._from_node(neighbors[0])
        return None

"#,
                to_model = rel.to_model,
                edge_type = rel
                    .traversal_hint
                    .edge_types
                    .first()
                    .unwrap_or(&"ContentLink".to_string()),
            ));
        } else {
            out.push_str(&format!(
                r#"    def {method_name}(self, limit: int = 10) -> {return_type}:
        """Navigate to related {to_model}s."""
        site = _ensure_mapped()
        neighbors = site.neighbors(self.node_id, edge_type="{edge_type}", limit=limit)
        return [{to_model}._from_node(n) for n in neighbors]

"#,
                to_model = rel.to_model,
                edge_type = rel
                    .traversal_hint
                    .edge_types
                    .first()
                    .unwrap_or(&"ContentLink".to_string()),
            ));
        }
    }

    // _from_node deserializer
    out.push_str(&format!(
        "    @staticmethod\n    def _from_node(node) -> '{}':\n        return {}(\n",
        model.name, model.name
    ));

    for field in &model.fields {
        let fname = safe_python_name(&field.name);
        if let Some(dim) = field.feature_dim {
            match field.field_type {
                FieldType::Integer => {
                    out.push_str(&format!(
                        "            {fname}=int(node.feature({dim}) or 0),\n"
                    ));
                }
                FieldType::Bool => {
                    out.push_str(&format!("            {fname}=bool(node.feature({dim})),\n"));
                }
                _ => {
                    out.push_str(&format!("            {fname}=node.feature({dim}),\n"));
                }
            }
        } else {
            match field.name.as_str() {
                "url" => out.push_str("            url=node.url,\n"),
                "node_id" => out.push_str("            node_id=node.index,\n"),
                "name" => {
                    out.push_str("            name=node.feature_str(0) or \"\",\n");
                }
                _ => {
                    out.push_str(&format!("            {fname}=None,\n"));
                }
            }
        }
    }
    out.push_str("        )\n\n");

    // _field_to_dim helper
    out.push_str(
        "    @staticmethod\n    def _field_to_dim(field_name: str) -> Optional[int]:\n        mapping = {\n"
    );
    for field in &model.fields {
        if let Some(dim) = field.feature_dim {
            out.push_str(&format!("            \"{}\": {},\n", field.name, dim));
        }
    }
    out.push_str("        }\n        return mapping.get(field_name)\n\n");

    out
}

/// Ensure a Python-safe variable name.
fn safe_python_name(name: &str) -> String {
    let reserved = [
        "and", "as", "assert", "async", "await", "break", "class", "continue", "def", "del",
        "elif", "else", "except", "finally", "for", "from", "global", "if", "import", "in", "is",
        "lambda", "nonlocal", "not", "or", "pass", "raise", "return", "try", "while", "with",
        "yield", "type",
    ];
    let snake = name.replace('-', "_");
    if reserved.contains(&snake.as_str()) {
        format!("{snake}_")
    } else {
        snake
    }
}

/// Convert a default value to Python literal.
fn python_default(value: &str, field_type: &FieldType) -> String {
    match field_type {
        FieldType::Integer => value.to_string(),
        FieldType::Float => {
            if value.contains('.') {
                value.to_string()
            } else {
                format!("{value}.0")
            }
        }
        FieldType::Bool => {
            if value == "true" || value == "1" {
                "True".to_string()
            } else {
                "False".to_string()
            }
        }
        FieldType::String | FieldType::Url => format!("\"{value}\""),
        _ => format!("\"{value}\""),
    }
}

/// Map Schema.org type to PageType hex value.
fn page_type_for_model(schema_type: &str) -> u8 {
    match schema_type {
        "Product" => 0x04,
        "ProductListing" => 0x03,
        "Article" | "TechArticle" => 0x05,
        "Review" => 0x10,
        "FAQPage" => 0x1E,
        "Organization" => 0x1C,
        "ContactPoint" => 0x1D,
        "Offer" => 0x1B,
        "MediaObject" => 0x0E,
        "Event" | "Calendar" => 0x19,
        "Cart" => 0x0A,
        "CheckoutPage" => 0x09,
        "Account" => 0x0B,
        "LoginPage" => 0x08,
        "WebSite" => 0x01,
        "SearchResultsPage" => 0x02,
        "Dashboard" => 0x12,
        _ => 0x00,
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use chrono::Utc;

    fn test_schema() -> CompiledSchema {
        CompiledSchema {
            domain: "shop.example.com".to_string(),
            compiled_at: Utc::now(),
            models: vec![DataModel {
                name: "Product".to_string(),
                schema_org_type: "Product".to_string(),
                fields: vec![
                    ModelField {
                        name: "url".to_string(),
                        field_type: FieldType::Url,
                        source: FieldSource::Inferred,
                        confidence: 1.0,
                        nullable: false,
                        example_values: vec![],
                        feature_dim: None,
                    },
                    ModelField {
                        name: "node_id".to_string(),
                        field_type: FieldType::Integer,
                        source: FieldSource::Inferred,
                        confidence: 1.0,
                        nullable: false,
                        example_values: vec![],
                        feature_dim: None,
                    },
                    ModelField {
                        name: "name".to_string(),
                        field_type: FieldType::String,
                        source: FieldSource::JsonLd,
                        confidence: 0.99,
                        nullable: false,
                        example_values: vec![],
                        feature_dim: None,
                    },
                    ModelField {
                        name: "price".to_string(),
                        field_type: FieldType::Float,
                        source: FieldSource::JsonLd,
                        confidence: 0.99,
                        nullable: true,
                        example_values: vec!["29.99".to_string()],
                        feature_dim: Some(48),
                    },
                    ModelField {
                        name: "rating".to_string(),
                        field_type: FieldType::Float,
                        source: FieldSource::JsonLd,
                        confidence: 0.95,
                        nullable: true,
                        example_values: vec!["4.5".to_string()],
                        feature_dim: Some(52),
                    },
                ],
                instance_count: 500,
                example_urls: vec!["https://shop.example.com/p/1".to_string()],
                search_action: Some(CompiledAction {
                    name: "search".to_string(),
                    belongs_to: "Product".to_string(),
                    is_instance_method: false,
                    http_method: "GET".to_string(),
                    endpoint_template: "/search?q={query}".to_string(),
                    params: vec![],
                    requires_auth: false,
                    execution_path: "http".to_string(),
                    confidence: 0.9,
                }),
                list_url: Some("https://shop.example.com/products".to_string()),
            }],
            actions: vec![CompiledAction {
                name: "add_to_cart".to_string(),
                belongs_to: "Product".to_string(),
                is_instance_method: true,
                http_method: "POST".to_string(),
                endpoint_template: "/cart/add".to_string(),
                params: vec![ActionParam {
                    name: "quantity".to_string(),
                    param_type: FieldType::Integer,
                    required: false,
                    default_value: Some("1".to_string()),
                    source: "json_body".to_string(),
                }],
                requires_auth: false,
                execution_path: "http".to_string(),
                confidence: 0.9,
            }],
            relationships: vec![],
            stats: SchemaStats {
                total_models: 1,
                total_fields: 5,
                total_instances: 500,
                avg_confidence: 0.95,
            },
        }
    }

    #[test]
    fn test_generate_python_contains_imports() {
        let schema = test_schema();
        let code = generate_python(&schema);

        assert!(code.contains("from __future__ import annotations"));
        assert!(code.contains("from dataclasses import dataclass"));
        assert!(code.contains("from cortex_client import"));
    }

    #[test]
    fn test_generate_python_contains_model() {
        let schema = test_schema();
        let code = generate_python(&schema);

        assert!(code.contains("@dataclass\nclass Product:"));
        assert!(code.contains("price: Optional[float]"));
        assert!(code.contains("url: str"));
    }

    #[test]
    fn test_generate_python_contains_methods() {
        let schema = test_schema();
        let code = generate_python(&schema);

        assert!(code.contains("def search("), "should have search method");
        assert!(
            code.contains("def add_to_cart(self"),
            "should have add_to_cart"
        );
        assert!(
            code.contains("def _from_node(node)"),
            "should have _from_node"
        );
    }

    #[test]
    fn test_safe_python_name() {
        assert_eq!(safe_python_name("price"), "price");
        assert_eq!(safe_python_name("class"), "class_");
        assert_eq!(safe_python_name("node-id"), "node_id");
        assert_eq!(safe_python_name("type"), "type_");
    }

    #[test]
    fn test_python_default_values() {
        assert_eq!(python_default("1", &FieldType::Integer), "1");
        assert_eq!(python_default("true", &FieldType::Bool), "True");
        assert_eq!(python_default("hello", &FieldType::String), "\"hello\"");
        assert_eq!(
            python_default("saved_card", &FieldType::String),
            "\"saved_card\""
        );
    }
}
